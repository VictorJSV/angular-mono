{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.spyOn = exports.mocked = exports.fn = exports.ModuleMocker = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/ban-types-eventually, local/prefer-rest-params-eventually */\n\n/**\n * Possible types of a MockFunctionResult.\n * 'return': The call completed by returning normally.\n * 'throw': The call completed by throwing a value.\n * 'incomplete': The call has not completed yet. This is possible if you read\n *               the  mock function result from within the mock function itself\n *               (or a function called by the mock function).\n */\n\n/**\n * Represents the result of a single call to a mock function.\n */\n// see https://github.com/Microsoft/TypeScript/issues/25215\n\n\nvar MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\nvar FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-\\/:-@\\[-`{-~]/;\nvar FUNCTION_NAME_RESERVED_REPLACE = new RegExp(FUNCTION_NAME_RESERVED_PATTERN.source, 'g');\nvar RESERVED_KEYWORDS = new Set(['arguments', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield']);\n\nfunction matchArity(fn, length) {\n  var mockConstructor;\n\n  switch (length) {\n    case 1:\n      mockConstructor = function (_a) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 2:\n      mockConstructor = function (_a, _b) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 3:\n      mockConstructor = function (_a, _b, _c) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 4:\n      mockConstructor = function (_a, _b, _c, _d) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 5:\n      mockConstructor = function (_a, _b, _c, _d, _e) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 6:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 7:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 8:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 9:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h, _i) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    default:\n      mockConstructor = function () {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n  }\n\n  return mockConstructor;\n}\n\nfunction getObjectType(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n\nfunction getType(ref) {\n  var typeName = getObjectType(ref);\n\n  if (typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction') {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (typeName === 'Object') {\n    return 'object';\n  } else if (typeName === 'Number' || typeName === 'String' || typeName === 'Boolean' || typeName === 'Symbol') {\n    return 'constant';\n  } else if (typeName === 'Map' || typeName === 'WeakMap' || typeName === 'Set') {\n    return 'collection';\n  } else if (typeName === 'RegExp') {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object, prop) {\n  if (prop === 'arguments' || prop === 'caller' || prop === 'callee' || prop === 'name' || prop === 'length') {\n    var typeName = getObjectType(object);\n    return typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction';\n  }\n\n  if (prop === 'source' || prop === 'global' || prop === 'ignoreCase' || prop === 'multiline') {\n    return getObjectType(object) === 'RegExp';\n  }\n\n  return false;\n}\n\nvar ModuleMocker = /*#__PURE__*/function () {\n  /**\n   * @see README.md\n   * @param global Global object of the test environment, used to create\n   * mocks\n   */\n  function ModuleMocker(global) {\n    _classCallCheck(this, ModuleMocker);\n\n    _defineProperty(this, '_environmentGlobal', void 0);\n\n    _defineProperty(this, '_mockState', void 0);\n\n    _defineProperty(this, '_mockConfigRegistry', void 0);\n\n    _defineProperty(this, '_spyState', void 0);\n\n    _defineProperty(this, '_invocationCallCounter', void 0);\n\n    this._environmentGlobal = global;\n    this._mockState = new WeakMap();\n    this._mockConfigRegistry = new WeakMap();\n    this._spyState = new Set();\n    this._invocationCallCounter = 1;\n  }\n\n  _createClass(ModuleMocker, [{\n    key: \"_getSlots\",\n    value: function _getSlots(object) {\n      if (!object) {\n        return [];\n      }\n\n      var slots = new Set();\n      var EnvObjectProto = this._environmentGlobal.Object.prototype;\n      var EnvFunctionProto = this._environmentGlobal.Function.prototype;\n      var EnvRegExpProto = this._environmentGlobal.RegExp.prototype; // Also check the builtins in the current context as they leak through\n      // core node modules.\n\n      var ObjectProto = Object.prototype;\n      var FunctionProto = Function.prototype;\n      var RegExpProto = RegExp.prototype; // Properties of Object.prototype, Function.prototype and RegExp.prototype\n      // are never reported as slots\n\n      while (object != null && object !== EnvObjectProto && object !== EnvFunctionProto && object !== EnvRegExpProto && object !== ObjectProto && object !== FunctionProto && object !== RegExpProto) {\n        var ownNames = Object.getOwnPropertyNames(object);\n\n        for (var i = 0; i < ownNames.length; i++) {\n          var prop = ownNames[i];\n\n          if (!isReadonlyProp(object, prop)) {\n            var propDesc = Object.getOwnPropertyDescriptor(object, prop);\n\n            if (propDesc !== undefined && !propDesc.get || object.__esModule) {\n              slots.add(prop);\n            }\n          }\n        }\n\n        object = Object.getPrototypeOf(object);\n      }\n\n      return Array.from(slots);\n    }\n  }, {\n    key: \"_ensureMockConfig\",\n    value: function _ensureMockConfig(f) {\n      var config = this._mockConfigRegistry.get(f);\n\n      if (!config) {\n        config = this._defaultMockConfig();\n\n        this._mockConfigRegistry.set(f, config);\n      }\n\n      return config;\n    }\n  }, {\n    key: \"_ensureMockState\",\n    value: function _ensureMockState(f) {\n      var state = this._mockState.get(f);\n\n      if (!state) {\n        state = this._defaultMockState();\n\n        this._mockState.set(f, state);\n      }\n\n      if (state.calls.length > 0) {\n        state.lastCall = state.calls[state.calls.length - 1];\n      }\n\n      return state;\n    }\n  }, {\n    key: \"_defaultMockConfig\",\n    value: function _defaultMockConfig() {\n      return {\n        mockImpl: undefined,\n        mockName: 'jest.fn()',\n        specificMockImpls: [],\n        specificReturnValues: []\n      };\n    }\n  }, {\n    key: \"_defaultMockState\",\n    value: function _defaultMockState() {\n      return {\n        calls: [],\n        instances: [],\n        invocationCallOrder: [],\n        results: []\n      };\n    }\n  }, {\n    key: \"_makeComponent\",\n    value: function _makeComponent(metadata, restore) {\n      var _this2 = this;\n\n      if (metadata.type === 'object') {\n        return new this._environmentGlobal.Object();\n      } else if (metadata.type === 'array') {\n        return new this._environmentGlobal.Array();\n      } else if (metadata.type === 'regexp') {\n        return new this._environmentGlobal.RegExp('');\n      } else if (metadata.type === 'constant' || metadata.type === 'collection' || metadata.type === 'null' || metadata.type === 'undefined') {\n        return metadata.value;\n      } else if (metadata.type === 'function') {\n        var prototype = metadata.members && metadata.members.prototype && metadata.members.prototype.members || {};\n\n        var prototypeSlots = this._getSlots(prototype);\n\n        var mocker = this;\n        var mockConstructor = matchArity(function () {\n          var _arguments = arguments,\n              _this = this;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          var mockState = mocker._ensureMockState(f);\n\n          var mockConfig = mocker._ensureMockConfig(f);\n\n          mockState.instances.push(this);\n          mockState.calls.push(args); // Create and record an \"incomplete\" mock result immediately upon\n          // calling rather than waiting for the mock to return. This avoids\n          // issues caused by recursion where results can be recorded in the\n          // wrong order.\n\n          var mockResult = {\n            type: 'incomplete',\n            value: undefined\n          };\n          mockState.results.push(mockResult);\n          mockState.invocationCallOrder.push(mocker._invocationCallCounter++); // Will be set to the return value of the mock if an error is not thrown\n\n          var finalReturnValue; // Will be set to the error that is thrown by the mock (if it throws)\n\n          var thrownError; // Will be set to true if the mock throws an error. The presence of a\n          // value in `thrownError` is not a 100% reliable indicator because a\n          // function could throw a value of undefined.\n\n          var callDidThrowError = false;\n\n          try {\n            // The bulk of the implementation is wrapped in an immediately\n            // executed arrow function so the return value of the mock function\n            // can be easily captured and recorded, despite the many separate\n            // return points within the logic.\n            finalReturnValue = function () {\n              if (_this instanceof f) {\n                // This is probably being called as a constructor\n                prototypeSlots.forEach(function (slot) {\n                  // Copy prototype methods to the instance to make\n                  // it easier to interact with mock instance call and\n                  // return values\n                  if (prototype[slot].type === 'function') {\n                    // @ts-expect-error no index signature\n                    var protoImpl = _this[slot]; // @ts-expect-error no index signature\n\n                    _this[slot] = mocker.generateFromMetadata(prototype[slot]); // @ts-expect-error no index signature\n\n                    _this[slot]._protoImpl = protoImpl;\n                  }\n                }); // Run the mock constructor implementation\n\n                var mockImpl = mockConfig.specificMockImpls.length ? mockConfig.specificMockImpls.shift() : mockConfig.mockImpl;\n                return mockImpl && mockImpl.apply(_this, _arguments);\n              } // If mockImplementationOnce()/mockImplementation() is last set,\n              // implementation use the mock\n\n\n              var specificMockImpl = mockConfig.specificMockImpls.shift();\n\n              if (specificMockImpl === undefined) {\n                specificMockImpl = mockConfig.mockImpl;\n              }\n\n              if (specificMockImpl) {\n                return specificMockImpl.apply(_this, _arguments);\n              } // Otherwise use prototype implementation\n\n\n              if (f._protoImpl) {\n                return f._protoImpl.apply(_this, _arguments);\n              }\n\n              return undefined;\n            }();\n          } catch (error) {\n            // Store the thrown error so we can record it, then re-throw it.\n            thrownError = error;\n            callDidThrowError = true;\n            throw error;\n          } finally {\n            // Record the result of the function.\n            // NOTE: Intentionally NOT pushing/indexing into the array of mock\n            //       results here to avoid corrupting results data if mockClear()\n            //       is called during the execution of the mock.\n            mockResult.type = callDidThrowError ? 'throw' : 'return';\n            mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n          }\n\n          return finalReturnValue;\n        }, metadata.length || 0);\n\n        var f = this._createMockFunction(metadata, mockConstructor);\n\n        f._isMockFunction = true;\n\n        f.getMockImplementation = function () {\n          return _this2._ensureMockConfig(f).mockImpl;\n        };\n\n        if (typeof restore === 'function') {\n          this._spyState.add(restore);\n        }\n\n        this._mockState.set(f, this._defaultMockState());\n\n        this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n        Object.defineProperty(f, 'mock', {\n          configurable: false,\n          enumerable: true,\n          get: function () {\n            return _this2._ensureMockState(f);\n          },\n          set: function (val) {\n            return _this2._mockState.set(f, val);\n          }\n        });\n\n        f.mockClear = function () {\n          _this2._mockState.delete(f);\n\n          return f;\n        };\n\n        f.mockReset = function () {\n          f.mockClear();\n\n          _this2._mockConfigRegistry.delete(f);\n\n          return f;\n        };\n\n        f.mockRestore = function () {\n          f.mockReset();\n          return restore ? restore() : undefined;\n        };\n\n        f.mockReturnValueOnce = function (value // next function call will return this value or default return value\n        ) {\n          return f.mockImplementationOnce(function () {\n            return value;\n          });\n        };\n\n        f.mockResolvedValueOnce = function (value) {\n          return f.mockImplementationOnce(function () {\n            return Promise.resolve(value);\n          });\n        };\n\n        f.mockRejectedValueOnce = function (value) {\n          return f.mockImplementationOnce(function () {\n            return Promise.reject(value);\n          });\n        };\n\n        f.mockReturnValue = function (value // next function call will return specified return value or this one\n        ) {\n          return f.mockImplementation(function () {\n            return value;\n          });\n        };\n\n        f.mockResolvedValue = function (value) {\n          return f.mockImplementation(function () {\n            return Promise.resolve(value);\n          });\n        };\n\n        f.mockRejectedValue = function (value) {\n          return f.mockImplementation(function () {\n            return Promise.reject(value);\n          });\n        };\n\n        f.mockImplementationOnce = function (fn) {\n          // next function call will use this mock implementation return value\n          // or default mock implementation return value\n          var mockConfig = _this2._ensureMockConfig(f);\n\n          mockConfig.specificMockImpls.push(fn);\n          return f;\n        };\n\n        f.mockImplementation = function (fn) {\n          // next function call will use mock implementation return value\n          var mockConfig = _this2._ensureMockConfig(f);\n\n          mockConfig.mockImpl = fn;\n          return f;\n        };\n\n        f.mockReturnThis = function () {\n          return f.mockImplementation(function () {\n            return this;\n          });\n        };\n\n        f.mockName = function (name) {\n          if (name) {\n            var mockConfig = _this2._ensureMockConfig(f);\n\n            mockConfig.mockName = name;\n          }\n\n          return f;\n        };\n\n        f.getMockName = function () {\n          var mockConfig = _this2._ensureMockConfig(f);\n\n          return mockConfig.mockName || 'jest.fn()';\n        };\n\n        if (metadata.mockImpl) {\n          f.mockImplementation(metadata.mockImpl);\n        }\n\n        return f;\n      } else {\n        var unknownType = metadata.type || 'undefined type';\n        throw new Error('Unrecognized type ' + unknownType);\n      }\n    }\n  }, {\n    key: \"_createMockFunction\",\n    value: function _createMockFunction(metadata, mockConstructor) {\n      var name = metadata.name;\n\n      if (!name) {\n        return mockConstructor;\n      } // Preserve `name` property of mocked function.\n\n\n      var boundFunctionPrefix = 'bound ';\n      var bindCall = ''; // if-do-while for perf reasons. The common case is for the if to fail.\n\n      if (name && name.startsWith(boundFunctionPrefix)) {\n        do {\n          name = name.substring(boundFunctionPrefix.length); // Call bind() just to alter the function name.\n\n          bindCall = '.bind(null)';\n        } while (name && name.startsWith(boundFunctionPrefix));\n      } // Special case functions named `mockConstructor` to guard for infinite\n      // loops.\n\n\n      if (name === MOCK_CONSTRUCTOR_NAME) {\n        return mockConstructor;\n      }\n\n      if ( // It's a syntax error to define functions with a reserved keyword\n      // as name.\n      RESERVED_KEYWORDS.has(name) || // It's also a syntax error to define functions with a name that starts with a number\n      /^\\d/.test(name)) {\n        name = '$' + name;\n      } // It's also a syntax error to define a function with a reserved character\n      // as part of it's name.\n\n\n      if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n        name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');\n      }\n\n      var body = 'return function ' + name + '() {' + 'return ' + MOCK_CONSTRUCTOR_NAME + '.apply(this,arguments);' + '}' + bindCall;\n      var createConstructor = new this._environmentGlobal.Function(MOCK_CONSTRUCTOR_NAME, body);\n      return createConstructor(mockConstructor);\n    }\n  }, {\n    key: \"_generateMock\",\n    value: function _generateMock(metadata, callbacks, refs) {\n      var _this3 = this; // metadata not compatible but it's the same type, maybe problem with\n      // overloading of _makeComponent and not _generateMock?\n      // @ts-expect-error\n\n\n      var mock = this._makeComponent(metadata);\n\n      if (metadata.refID != null) {\n        refs[metadata.refID] = mock;\n      }\n\n      this._getSlots(metadata.members).forEach(function (slot) {\n        var slotMetadata = metadata.members && metadata.members[slot] || {};\n\n        if (slotMetadata.ref != null) {\n          callbacks.push(function (ref) {\n            return function () {\n              return mock[slot] = refs[ref];\n            };\n          }(slotMetadata.ref));\n        } else {\n          mock[slot] = _this3._generateMock(slotMetadata, callbacks, refs);\n        }\n      });\n\n      if (metadata.type !== 'undefined' && metadata.type !== 'null' && mock.prototype && typeof mock.prototype === 'object') {\n        mock.prototype.constructor = mock;\n      }\n\n      return mock;\n    }\n    /**\n     * @see README.md\n     * @param _metadata Metadata for the mock in the schema returned by the\n     * getMetadata method of this module.\n     */\n\n  }, {\n    key: \"generateFromMetadata\",\n    value: function generateFromMetadata(_metadata) {\n      var callbacks = [];\n      var refs = {};\n\n      var mock = this._generateMock(_metadata, callbacks, refs);\n\n      callbacks.forEach(function (setter) {\n        return setter();\n      });\n      return mock;\n    }\n    /**\n     * @see README.md\n     * @param component The component for which to retrieve metadata.\n     */\n\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(component, _refs) {\n      var _this4 = this;\n\n      var refs = _refs || new Map();\n      var ref = refs.get(component);\n\n      if (ref != null) {\n        return {\n          ref: ref\n        };\n      }\n\n      var type = getType(component);\n\n      if (!type) {\n        return null;\n      }\n\n      var metadata = {\n        type: type\n      };\n\n      if (type === 'constant' || type === 'collection' || type === 'undefined' || type === 'null') {\n        metadata.value = component;\n        return metadata;\n      } else if (type === 'function') {\n        // @ts-expect-error this is a function so it has a name\n        metadata.name = component.name; // @ts-expect-error may be a mock\n\n        if (component._isMockFunction === true) {\n          // @ts-expect-error may be a mock\n          metadata.mockImpl = component.getMockImplementation();\n        }\n      }\n\n      metadata.refID = refs.size;\n      refs.set(component, metadata.refID);\n      var members = null; // Leave arrays alone\n\n      if (type !== 'array') {\n        this._getSlots(component).forEach(function (slot) {\n          if (type === 'function' && // @ts-expect-error may be a mock\n          component._isMockFunction === true && slot.match(/^mock/)) {\n            return;\n          } // @ts-expect-error no index signature\n\n\n          var slotMetadata = _this4.getMetadata(component[slot], refs);\n\n          if (slotMetadata) {\n            if (!members) {\n              members = {};\n            }\n\n            members[slot] = slotMetadata;\n          }\n        });\n      }\n\n      if (members) {\n        metadata.members = members;\n      }\n\n      return metadata;\n    }\n  }, {\n    key: \"isMockFunction\",\n    value: function isMockFunction(fn) {\n      return !!fn && fn._isMockFunction === true;\n    }\n  }, {\n    key: \"fn\",\n    value: function fn(implementation) {\n      var length = implementation ? implementation.length : 0;\n\n      var fn = this._makeComponent({\n        length: length,\n        type: 'function'\n      });\n\n      if (implementation) {\n        fn.mockImplementation(implementation);\n      }\n\n      return fn;\n    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n  }, {\n    key: \"spyOn\",\n    value: function spyOn(object, methodName, accessType) {\n      if (accessType) {\n        return this._spyOnProperty(object, methodName, accessType);\n      }\n\n      if (typeof object !== 'object' && typeof object !== 'function') {\n        throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given');\n      }\n\n      var original = object[methodName];\n\n      if (!this.isMockFunction(original)) {\n        if (typeof original !== 'function') {\n          throw new Error('Cannot spy the ' + methodName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');\n        }\n\n        var isMethodOwner = Object.prototype.hasOwnProperty.call(object, methodName);\n        var descriptor = Object.getOwnPropertyDescriptor(object, methodName);\n        var proto = Object.getPrototypeOf(object);\n\n        while (!descriptor && proto !== null) {\n          descriptor = Object.getOwnPropertyDescriptor(proto, methodName);\n          proto = Object.getPrototypeOf(proto);\n        }\n\n        var mock;\n\n        if (descriptor && descriptor.get) {\n          var originalGet = descriptor.get;\n          mock = this._makeComponent({\n            type: 'function'\n          }, function () {\n            descriptor.get = originalGet;\n            Object.defineProperty(object, methodName, descriptor);\n          });\n\n          descriptor.get = function () {\n            return mock;\n          };\n\n          Object.defineProperty(object, methodName, descriptor);\n        } else {\n          mock = this._makeComponent({\n            type: 'function'\n          }, function () {\n            if (isMethodOwner) {\n              object[methodName] = original;\n            } else {\n              delete object[methodName];\n            }\n          }); // @ts-expect-error overriding original method with a Mock\n\n          object[methodName] = mock;\n        }\n\n        mock.mockImplementation(function () {\n          return original.apply(this, arguments);\n        });\n      }\n\n      return object[methodName];\n    }\n  }, {\n    key: \"_spyOnProperty\",\n    value: function _spyOnProperty(obj, propertyName) {\n      var accessType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'get';\n\n      if (typeof obj !== 'object' && typeof obj !== 'function') {\n        throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given');\n      }\n\n      if (!obj) {\n        throw new Error('spyOn could not find an object to spy upon for ' + propertyName + '');\n      }\n\n      if (!propertyName) {\n        throw new Error('No property name supplied');\n      }\n\n      var descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n      var proto = Object.getPrototypeOf(obj);\n\n      while (!descriptor && proto !== null) {\n        descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      if (!descriptor) {\n        throw new Error(propertyName + ' property does not exist');\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(propertyName + ' is not declared configurable');\n      }\n\n      if (!descriptor[accessType]) {\n        throw new Error('Property ' + propertyName + ' does not have access type ' + accessType);\n      }\n\n      var original = descriptor[accessType];\n\n      if (!this.isMockFunction(original)) {\n        if (typeof original !== 'function') {\n          throw new Error('Cannot spy the ' + propertyName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');\n        } // @ts-expect-error: mock is assignable\n\n\n        descriptor[accessType] = this._makeComponent({\n          type: 'function'\n        }, function () {\n          // @ts-expect-error: mock is assignable\n          descriptor[accessType] = original;\n          Object.defineProperty(obj, propertyName, descriptor);\n        });\n        descriptor[accessType].mockImplementation(function () {\n          // @ts-expect-error\n          return original.apply(this, arguments);\n        });\n      }\n\n      Object.defineProperty(obj, propertyName, descriptor);\n      return descriptor[accessType];\n    }\n  }, {\n    key: \"clearAllMocks\",\n    value: function clearAllMocks() {\n      this._mockState = new WeakMap();\n    }\n  }, {\n    key: \"resetAllMocks\",\n    value: function resetAllMocks() {\n      this._mockConfigRegistry = new WeakMap();\n      this._mockState = new WeakMap();\n    }\n  }, {\n    key: \"restoreAllMocks\",\n    value: function restoreAllMocks() {\n      this._spyState.forEach(function (restore) {\n        return restore();\n      });\n\n      this._spyState = new Set();\n    }\n  }, {\n    key: \"_typeOf\",\n    value: function _typeOf(value) {\n      return value == null ? '' + value : typeof value;\n    } // the typings test helper\n\n  }, {\n    key: \"mocked\",\n    value: function mocked(item) {\n      var _deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      return item;\n    }\n  }]);\n\n  return ModuleMocker;\n}();\n\nexports.ModuleMocker = ModuleMocker;\nvar JestMock = new ModuleMocker(global);\nvar fn = JestMock.fn.bind(JestMock);\nexports.fn = fn;\nvar spyOn = JestMock.spyOn.bind(JestMock);\nexports.spyOn = spyOn;\nvar mocked = JestMock.mocked.bind(JestMock);\nexports.mocked = mocked;","map":{"version":3,"mappings":"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","names":["Object","defineProperty","exports","value","spyOn","mocked","fn","ModuleMocker","_defineProperty","obj","key","enumerable","configurable","writable","MOCK_CONSTRUCTOR_NAME","FUNCTION_NAME_RESERVED_PATTERN","FUNCTION_NAME_RESERVED_REPLACE","RegExp","source","RESERVED_KEYWORDS","Set","matchArity","length","mockConstructor","_a","apply","arguments","_b","_c","_d","_e","_f","_g","_h","_i","getObjectType","prototype","toString","slice","getType","ref","typeName","Array","isArray","undefined","isReadonlyProp","object","prop","global","_classCallCheck","_environmentGlobal","_mockState","WeakMap","_mockConfigRegistry","_spyState","_invocationCallCounter","slots","EnvObjectProto","EnvFunctionProto","Function","EnvRegExpProto","ObjectProto","FunctionProto","RegExpProto","ownNames","getOwnPropertyNames","i","propDesc","getOwnPropertyDescriptor","get","__esModule","add","getPrototypeOf","from","f","config","_defaultMockConfig","set","state","_defaultMockState","calls","lastCall","mockImpl","mockName","specificMockImpls","specificReturnValues","instances","invocationCallOrder","results","metadata","restore","type","members","prototypeSlots","_getSlots","mocker","args","mockState","_ensureMockState","mockConfig","_ensureMockConfig","push","mockResult","finalReturnValue","thrownError","callDidThrowError","_this","forEach","slot","protoImpl","generateFromMetadata","_protoImpl","shift","specificMockImpl","error","_createMockFunction","_isMockFunction","getMockImplementation","_this2","val","mockClear","delete","mockReset","mockRestore","mockReturnValueOnce","mockImplementationOnce","mockResolvedValueOnce","Promise","resolve","mockRejectedValueOnce","reject","mockReturnValue","mockImplementation","mockResolvedValue","mockRejectedValue","mockReturnThis","name","getMockName","unknownType","Error","boundFunctionPrefix","bindCall","startsWith","substring","has","test","replace","body","createConstructor","callbacks","refs","mock","_makeComponent","refID","slotMetadata","_this3","_generateMock","constructor","_metadata","setter","component","_refs","Map","size","match","_this4","getMetadata","implementation","methodName","accessType","_spyOnProperty","_typeOf","original","isMockFunction","isMethodOwner","hasOwnProperty","call","descriptor","proto","originalGet","propertyName","item","_deep","JestMock","bind"],"sources":["/Users/victorsan/Documents/htdocs/wabi-demo-monorepo/node_modules/jest-mock/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.spyOn = exports.mocked = exports.fn = exports.ModuleMocker = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/ban-types-eventually, local/prefer-rest-params-eventually */\n\n/**\n * Possible types of a MockFunctionResult.\n * 'return': The call completed by returning normally.\n * 'throw': The call completed by throwing a value.\n * 'incomplete': The call has not completed yet. This is possible if you read\n *               the  mock function result from within the mock function itself\n *               (or a function called by the mock function).\n */\n\n/**\n * Represents the result of a single call to a mock function.\n */\n// see https://github.com/Microsoft/TypeScript/issues/25215\nconst MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\nconst FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-\\/:-@\\[-`{-~]/;\nconst FUNCTION_NAME_RESERVED_REPLACE = new RegExp(\n  FUNCTION_NAME_RESERVED_PATTERN.source,\n  'g'\n);\nconst RESERVED_KEYWORDS = new Set([\n  'arguments',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield'\n]);\n\nfunction matchArity(fn, length) {\n  let mockConstructor;\n\n  switch (length) {\n    case 1:\n      mockConstructor = function (_a) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 2:\n      mockConstructor = function (_a, _b) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 3:\n      mockConstructor = function (_a, _b, _c) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 4:\n      mockConstructor = function (_a, _b, _c, _d) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 5:\n      mockConstructor = function (_a, _b, _c, _d, _e) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 6:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 7:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 8:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 9:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h, _i) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    default:\n      mockConstructor = function () {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n  }\n\n  return mockConstructor;\n}\n\nfunction getObjectType(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n\nfunction getType(ref) {\n  const typeName = getObjectType(ref);\n\n  if (\n    typeName === 'Function' ||\n    typeName === 'AsyncFunction' ||\n    typeName === 'GeneratorFunction'\n  ) {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (typeName === 'Object') {\n    return 'object';\n  } else if (\n    typeName === 'Number' ||\n    typeName === 'String' ||\n    typeName === 'Boolean' ||\n    typeName === 'Symbol'\n  ) {\n    return 'constant';\n  } else if (\n    typeName === 'Map' ||\n    typeName === 'WeakMap' ||\n    typeName === 'Set'\n  ) {\n    return 'collection';\n  } else if (typeName === 'RegExp') {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object, prop) {\n  if (\n    prop === 'arguments' ||\n    prop === 'caller' ||\n    prop === 'callee' ||\n    prop === 'name' ||\n    prop === 'length'\n  ) {\n    const typeName = getObjectType(object);\n    return (\n      typeName === 'Function' ||\n      typeName === 'AsyncFunction' ||\n      typeName === 'GeneratorFunction'\n    );\n  }\n\n  if (\n    prop === 'source' ||\n    prop === 'global' ||\n    prop === 'ignoreCase' ||\n    prop === 'multiline'\n  ) {\n    return getObjectType(object) === 'RegExp';\n  }\n\n  return false;\n}\n\nclass ModuleMocker {\n  /**\n   * @see README.md\n   * @param global Global object of the test environment, used to create\n   * mocks\n   */\n  constructor(global) {\n    _defineProperty(this, '_environmentGlobal', void 0);\n\n    _defineProperty(this, '_mockState', void 0);\n\n    _defineProperty(this, '_mockConfigRegistry', void 0);\n\n    _defineProperty(this, '_spyState', void 0);\n\n    _defineProperty(this, '_invocationCallCounter', void 0);\n\n    this._environmentGlobal = global;\n    this._mockState = new WeakMap();\n    this._mockConfigRegistry = new WeakMap();\n    this._spyState = new Set();\n    this._invocationCallCounter = 1;\n  }\n\n  _getSlots(object) {\n    if (!object) {\n      return [];\n    }\n\n    const slots = new Set();\n    const EnvObjectProto = this._environmentGlobal.Object.prototype;\n    const EnvFunctionProto = this._environmentGlobal.Function.prototype;\n    const EnvRegExpProto = this._environmentGlobal.RegExp.prototype; // Also check the builtins in the current context as they leak through\n    // core node modules.\n\n    const ObjectProto = Object.prototype;\n    const FunctionProto = Function.prototype;\n    const RegExpProto = RegExp.prototype; // Properties of Object.prototype, Function.prototype and RegExp.prototype\n    // are never reported as slots\n\n    while (\n      object != null &&\n      object !== EnvObjectProto &&\n      object !== EnvFunctionProto &&\n      object !== EnvRegExpProto &&\n      object !== ObjectProto &&\n      object !== FunctionProto &&\n      object !== RegExpProto\n    ) {\n      const ownNames = Object.getOwnPropertyNames(object);\n\n      for (let i = 0; i < ownNames.length; i++) {\n        const prop = ownNames[i];\n\n        if (!isReadonlyProp(object, prop)) {\n          const propDesc = Object.getOwnPropertyDescriptor(object, prop);\n\n          if ((propDesc !== undefined && !propDesc.get) || object.__esModule) {\n            slots.add(prop);\n          }\n        }\n      }\n\n      object = Object.getPrototypeOf(object);\n    }\n\n    return Array.from(slots);\n  }\n\n  _ensureMockConfig(f) {\n    let config = this._mockConfigRegistry.get(f);\n\n    if (!config) {\n      config = this._defaultMockConfig();\n\n      this._mockConfigRegistry.set(f, config);\n    }\n\n    return config;\n  }\n\n  _ensureMockState(f) {\n    let state = this._mockState.get(f);\n\n    if (!state) {\n      state = this._defaultMockState();\n\n      this._mockState.set(f, state);\n    }\n\n    if (state.calls.length > 0) {\n      state.lastCall = state.calls[state.calls.length - 1];\n    }\n\n    return state;\n  }\n\n  _defaultMockConfig() {\n    return {\n      mockImpl: undefined,\n      mockName: 'jest.fn()',\n      specificMockImpls: [],\n      specificReturnValues: []\n    };\n  }\n\n  _defaultMockState() {\n    return {\n      calls: [],\n      instances: [],\n      invocationCallOrder: [],\n      results: []\n    };\n  }\n\n  _makeComponent(metadata, restore) {\n    if (metadata.type === 'object') {\n      return new this._environmentGlobal.Object();\n    } else if (metadata.type === 'array') {\n      return new this._environmentGlobal.Array();\n    } else if (metadata.type === 'regexp') {\n      return new this._environmentGlobal.RegExp('');\n    } else if (\n      metadata.type === 'constant' ||\n      metadata.type === 'collection' ||\n      metadata.type === 'null' ||\n      metadata.type === 'undefined'\n    ) {\n      return metadata.value;\n    } else if (metadata.type === 'function') {\n      const prototype =\n        (metadata.members &&\n          metadata.members.prototype &&\n          metadata.members.prototype.members) ||\n        {};\n\n      const prototypeSlots = this._getSlots(prototype);\n\n      const mocker = this;\n      const mockConstructor = matchArity(function (...args) {\n        const mockState = mocker._ensureMockState(f);\n\n        const mockConfig = mocker._ensureMockConfig(f);\n\n        mockState.instances.push(this);\n        mockState.calls.push(args); // Create and record an \"incomplete\" mock result immediately upon\n        // calling rather than waiting for the mock to return. This avoids\n        // issues caused by recursion where results can be recorded in the\n        // wrong order.\n\n        const mockResult = {\n          type: 'incomplete',\n          value: undefined\n        };\n        mockState.results.push(mockResult);\n        mockState.invocationCallOrder.push(mocker._invocationCallCounter++); // Will be set to the return value of the mock if an error is not thrown\n\n        let finalReturnValue; // Will be set to the error that is thrown by the mock (if it throws)\n\n        let thrownError; // Will be set to true if the mock throws an error. The presence of a\n        // value in `thrownError` is not a 100% reliable indicator because a\n        // function could throw a value of undefined.\n\n        let callDidThrowError = false;\n\n        try {\n          // The bulk of the implementation is wrapped in an immediately\n          // executed arrow function so the return value of the mock function\n          // can be easily captured and recorded, despite the many separate\n          // return points within the logic.\n          finalReturnValue = (() => {\n            if (this instanceof f) {\n              // This is probably being called as a constructor\n              prototypeSlots.forEach(slot => {\n                // Copy prototype methods to the instance to make\n                // it easier to interact with mock instance call and\n                // return values\n                if (prototype[slot].type === 'function') {\n                  // @ts-expect-error no index signature\n                  const protoImpl = this[slot]; // @ts-expect-error no index signature\n\n                  this[slot] = mocker.generateFromMetadata(prototype[slot]); // @ts-expect-error no index signature\n\n                  this[slot]._protoImpl = protoImpl;\n                }\n              }); // Run the mock constructor implementation\n\n              const mockImpl = mockConfig.specificMockImpls.length\n                ? mockConfig.specificMockImpls.shift()\n                : mockConfig.mockImpl;\n              return mockImpl && mockImpl.apply(this, arguments);\n            } // If mockImplementationOnce()/mockImplementation() is last set,\n            // implementation use the mock\n\n            let specificMockImpl = mockConfig.specificMockImpls.shift();\n\n            if (specificMockImpl === undefined) {\n              specificMockImpl = mockConfig.mockImpl;\n            }\n\n            if (specificMockImpl) {\n              return specificMockImpl.apply(this, arguments);\n            } // Otherwise use prototype implementation\n\n            if (f._protoImpl) {\n              return f._protoImpl.apply(this, arguments);\n            }\n\n            return undefined;\n          })();\n        } catch (error) {\n          // Store the thrown error so we can record it, then re-throw it.\n          thrownError = error;\n          callDidThrowError = true;\n          throw error;\n        } finally {\n          // Record the result of the function.\n          // NOTE: Intentionally NOT pushing/indexing into the array of mock\n          //       results here to avoid corrupting results data if mockClear()\n          //       is called during the execution of the mock.\n          mockResult.type = callDidThrowError ? 'throw' : 'return';\n          mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n        }\n\n        return finalReturnValue;\n      }, metadata.length || 0);\n\n      const f = this._createMockFunction(metadata, mockConstructor);\n\n      f._isMockFunction = true;\n\n      f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl;\n\n      if (typeof restore === 'function') {\n        this._spyState.add(restore);\n      }\n\n      this._mockState.set(f, this._defaultMockState());\n\n      this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n      Object.defineProperty(f, 'mock', {\n        configurable: false,\n        enumerable: true,\n        get: () => this._ensureMockState(f),\n        set: val => this._mockState.set(f, val)\n      });\n\n      f.mockClear = () => {\n        this._mockState.delete(f);\n\n        return f;\n      };\n\n      f.mockReset = () => {\n        f.mockClear();\n\n        this._mockConfigRegistry.delete(f);\n\n        return f;\n      };\n\n      f.mockRestore = () => {\n        f.mockReset();\n        return restore ? restore() : undefined;\n      };\n\n      f.mockReturnValueOnce = (\n        value // next function call will return this value or default return value\n      ) => f.mockImplementationOnce(() => value);\n\n      f.mockResolvedValueOnce = value =>\n        f.mockImplementationOnce(() => Promise.resolve(value));\n\n      f.mockRejectedValueOnce = value =>\n        f.mockImplementationOnce(() => Promise.reject(value));\n\n      f.mockReturnValue = (\n        value // next function call will return specified return value or this one\n      ) => f.mockImplementation(() => value);\n\n      f.mockResolvedValue = value =>\n        f.mockImplementation(() => Promise.resolve(value));\n\n      f.mockRejectedValue = value =>\n        f.mockImplementation(() => Promise.reject(value));\n\n      f.mockImplementationOnce = fn => {\n        // next function call will use this mock implementation return value\n        // or default mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.specificMockImpls.push(fn);\n        return f;\n      };\n\n      f.mockImplementation = fn => {\n        // next function call will use mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.mockImpl = fn;\n        return f;\n      };\n\n      f.mockReturnThis = () =>\n        f.mockImplementation(function () {\n          return this;\n        });\n\n      f.mockName = name => {\n        if (name) {\n          const mockConfig = this._ensureMockConfig(f);\n\n          mockConfig.mockName = name;\n        }\n\n        return f;\n      };\n\n      f.getMockName = () => {\n        const mockConfig = this._ensureMockConfig(f);\n\n        return mockConfig.mockName || 'jest.fn()';\n      };\n\n      if (metadata.mockImpl) {\n        f.mockImplementation(metadata.mockImpl);\n      }\n\n      return f;\n    } else {\n      const unknownType = metadata.type || 'undefined type';\n      throw new Error('Unrecognized type ' + unknownType);\n    }\n  }\n\n  _createMockFunction(metadata, mockConstructor) {\n    let name = metadata.name;\n\n    if (!name) {\n      return mockConstructor;\n    } // Preserve `name` property of mocked function.\n\n    const boundFunctionPrefix = 'bound ';\n    let bindCall = ''; // if-do-while for perf reasons. The common case is for the if to fail.\n\n    if (name && name.startsWith(boundFunctionPrefix)) {\n      do {\n        name = name.substring(boundFunctionPrefix.length); // Call bind() just to alter the function name.\n\n        bindCall = '.bind(null)';\n      } while (name && name.startsWith(boundFunctionPrefix));\n    } // Special case functions named `mockConstructor` to guard for infinite\n    // loops.\n\n    if (name === MOCK_CONSTRUCTOR_NAME) {\n      return mockConstructor;\n    }\n\n    if (\n      // It's a syntax error to define functions with a reserved keyword\n      // as name.\n      RESERVED_KEYWORDS.has(name) || // It's also a syntax error to define functions with a name that starts with a number\n      /^\\d/.test(name)\n    ) {\n      name = '$' + name;\n    } // It's also a syntax error to define a function with a reserved character\n    // as part of it's name.\n\n    if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n      name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');\n    }\n\n    const body =\n      'return function ' +\n      name +\n      '() {' +\n      'return ' +\n      MOCK_CONSTRUCTOR_NAME +\n      '.apply(this,arguments);' +\n      '}' +\n      bindCall;\n    const createConstructor = new this._environmentGlobal.Function(\n      MOCK_CONSTRUCTOR_NAME,\n      body\n    );\n    return createConstructor(mockConstructor);\n  }\n\n  _generateMock(metadata, callbacks, refs) {\n    // metadata not compatible but it's the same type, maybe problem with\n    // overloading of _makeComponent and not _generateMock?\n    // @ts-expect-error\n    const mock = this._makeComponent(metadata);\n\n    if (metadata.refID != null) {\n      refs[metadata.refID] = mock;\n    }\n\n    this._getSlots(metadata.members).forEach(slot => {\n      const slotMetadata = (metadata.members && metadata.members[slot]) || {};\n\n      if (slotMetadata.ref != null) {\n        callbacks.push(\n          (function (ref) {\n            return () => (mock[slot] = refs[ref]);\n          })(slotMetadata.ref)\n        );\n      } else {\n        mock[slot] = this._generateMock(slotMetadata, callbacks, refs);\n      }\n    });\n\n    if (\n      metadata.type !== 'undefined' &&\n      metadata.type !== 'null' &&\n      mock.prototype &&\n      typeof mock.prototype === 'object'\n    ) {\n      mock.prototype.constructor = mock;\n    }\n\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param _metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   */\n\n  generateFromMetadata(_metadata) {\n    const callbacks = [];\n    const refs = {};\n\n    const mock = this._generateMock(_metadata, callbacks, refs);\n\n    callbacks.forEach(setter => setter());\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param component The component for which to retrieve metadata.\n   */\n\n  getMetadata(component, _refs) {\n    const refs = _refs || new Map();\n    const ref = refs.get(component);\n\n    if (ref != null) {\n      return {\n        ref\n      };\n    }\n\n    const type = getType(component);\n\n    if (!type) {\n      return null;\n    }\n\n    const metadata = {\n      type\n    };\n\n    if (\n      type === 'constant' ||\n      type === 'collection' ||\n      type === 'undefined' ||\n      type === 'null'\n    ) {\n      metadata.value = component;\n      return metadata;\n    } else if (type === 'function') {\n      // @ts-expect-error this is a function so it has a name\n      metadata.name = component.name; // @ts-expect-error may be a mock\n\n      if (component._isMockFunction === true) {\n        // @ts-expect-error may be a mock\n        metadata.mockImpl = component.getMockImplementation();\n      }\n    }\n\n    metadata.refID = refs.size;\n    refs.set(component, metadata.refID);\n    let members = null; // Leave arrays alone\n\n    if (type !== 'array') {\n      this._getSlots(component).forEach(slot => {\n        if (\n          type === 'function' && // @ts-expect-error may be a mock\n          component._isMockFunction === true &&\n          slot.match(/^mock/)\n        ) {\n          return;\n        } // @ts-expect-error no index signature\n\n        const slotMetadata = this.getMetadata(component[slot], refs);\n\n        if (slotMetadata) {\n          if (!members) {\n            members = {};\n          }\n\n          members[slot] = slotMetadata;\n        }\n      });\n    }\n\n    if (members) {\n      metadata.members = members;\n    }\n\n    return metadata;\n  }\n\n  isMockFunction(fn) {\n    return !!fn && fn._isMockFunction === true;\n  }\n\n  fn(implementation) {\n    const length = implementation ? implementation.length : 0;\n\n    const fn = this._makeComponent({\n      length,\n      type: 'function'\n    });\n\n    if (implementation) {\n      fn.mockImplementation(implementation);\n    }\n\n    return fn;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  spyOn(object, methodName, accessType) {\n    if (accessType) {\n      return this._spyOnProperty(object, methodName, accessType);\n    }\n\n    if (typeof object !== 'object' && typeof object !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given'\n      );\n    }\n\n    const original = object[methodName];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            methodName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead'\n        );\n      }\n\n      const isMethodOwner = Object.prototype.hasOwnProperty.call(\n        object,\n        methodName\n      );\n      let descriptor = Object.getOwnPropertyDescriptor(object, methodName);\n      let proto = Object.getPrototypeOf(object);\n\n      while (!descriptor && proto !== null) {\n        descriptor = Object.getOwnPropertyDescriptor(proto, methodName);\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      let mock;\n\n      if (descriptor && descriptor.get) {\n        const originalGet = descriptor.get;\n        mock = this._makeComponent(\n          {\n            type: 'function'\n          },\n          () => {\n            descriptor.get = originalGet;\n            Object.defineProperty(object, methodName, descriptor);\n          }\n        );\n\n        descriptor.get = () => mock;\n\n        Object.defineProperty(object, methodName, descriptor);\n      } else {\n        mock = this._makeComponent(\n          {\n            type: 'function'\n          },\n          () => {\n            if (isMethodOwner) {\n              object[methodName] = original;\n            } else {\n              delete object[methodName];\n            }\n          }\n        ); // @ts-expect-error overriding original method with a Mock\n\n        object[methodName] = mock;\n      }\n\n      mock.mockImplementation(function () {\n        return original.apply(this, arguments);\n      });\n    }\n\n    return object[methodName];\n  }\n\n  _spyOnProperty(obj, propertyName, accessType = 'get') {\n    if (typeof obj !== 'object' && typeof obj !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given'\n      );\n    }\n\n    if (!obj) {\n      throw new Error(\n        'spyOn could not find an object to spy upon for ' + propertyName + ''\n      );\n    }\n\n    if (!propertyName) {\n      throw new Error('No property name supplied');\n    }\n\n    let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n    let proto = Object.getPrototypeOf(obj);\n\n    while (!descriptor && proto !== null) {\n      descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    if (!descriptor) {\n      throw new Error(propertyName + ' property does not exist');\n    }\n\n    if (!descriptor.configurable) {\n      throw new Error(propertyName + ' is not declared configurable');\n    }\n\n    if (!descriptor[accessType]) {\n      throw new Error(\n        'Property ' + propertyName + ' does not have access type ' + accessType\n      );\n    }\n\n    const original = descriptor[accessType];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            propertyName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead'\n        );\n      } // @ts-expect-error: mock is assignable\n\n      descriptor[accessType] = this._makeComponent(\n        {\n          type: 'function'\n        },\n        () => {\n          // @ts-expect-error: mock is assignable\n          descriptor[accessType] = original;\n          Object.defineProperty(obj, propertyName, descriptor);\n        }\n      );\n      descriptor[accessType].mockImplementation(function () {\n        // @ts-expect-error\n        return original.apply(this, arguments);\n      });\n    }\n\n    Object.defineProperty(obj, propertyName, descriptor);\n    return descriptor[accessType];\n  }\n\n  clearAllMocks() {\n    this._mockState = new WeakMap();\n  }\n\n  resetAllMocks() {\n    this._mockConfigRegistry = new WeakMap();\n    this._mockState = new WeakMap();\n  }\n\n  restoreAllMocks() {\n    this._spyState.forEach(restore => restore());\n\n    this._spyState = new Set();\n  }\n\n  _typeOf(value) {\n    return value == null ? '' + value : typeof value;\n  } // the typings test helper\n\n  mocked(item, _deep = false) {\n    return item;\n  }\n}\n\nexports.ModuleMocker = ModuleMocker;\nconst JestMock = new ModuleMocker(global);\nconst fn = JestMock.fn.bind(JestMock);\nexports.fn = fn;\nconst spyOn = JestMock.spyOn.bind(JestMock);\nexports.spyOn = spyOn;\nconst mocked = JestMock.mocked.bind(JestMock);\nexports.mocked = mocked;\n"]},"metadata":{},"sourceType":"script"}